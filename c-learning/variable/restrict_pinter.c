/*
 * =======================================
 *  restrict
 * =======================================
 */

#include <stdio.h>
#include <stdlib.h>

/**
 * C99 引入的 restrict 修饰符：关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的
 * 唯一且初始的方式。
 */
int main() {
    // 什么是数据对象的唯一且初始的方式？
    int arr1[10];

    // 指针 arr2 是访问由 malloc() 所分配内存的唯一且初始的方式。因此，可以用 restrict 关键字限定它。
    int* restrict arr2 = (int*)malloc(10 * sizeof(int));

    // 指针 parr 既不是访问 arr1 数组中数据的初始方式，也不是唯一方式。所以不用把它设置为 restrict。
    int* parr1 = arr1;

    /*
     * 编译器可以对 restrict 修饰的指针进行优化：
     *
     *  - 由于之前声明了 arr2 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 arr2 的两条语句替换成
     *    arr2[n] += 8;。这种替换不会导致程序错误。
     *
     *  - 如果把与 parr1 相关的两条语句替换成 par[n] += 8;，将导致计算错误，因为 for 循环在 par 两次访问相同的数据
     *    之间，用 ar 改变了该数据的值。
     *
     *  - 如果未使用 restrict 关键字，编译器就必须假设最坏的情况（即，在两次使用指针之间，其他的标识符可能已经改变了数据）
     *    如果用了 restrict 关键字，编译器就可以选择捷径优化计算。
     */
    for (int n = 0; n < 10; n++) {
        parr1[n] += 5;
        arr2[n] += 5;
        arr1[n] *= 2;
        parr1[n] += 3;
        arr2[n] += 3;
    }

    free(arr2);

    /*
     * restrict 限定符还可用于函数形参中的指针：这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编
     * 译器可以尝试对其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在 C99 中，这两
     * 个函数的原型是：
     */

    // memcpy() 函数要求两个位置不重叠，声明 s1 和 s2 为 restrict 说明这两个指针都是访问相应数据的唯一方式，所以它们不
    // 能访问相同块的数据。这满足了 memcpy() 无重叠的要求。
    void * memcpy(void * restrict s1, const void * restrict s2, size_t n);

    // memmove() 函数允许重叠，它在拷贝数据时不得不更小心，以防在使用数据之前就先覆盖了数据。
    void * memmove(void * s1, const void * s2, size_t n);

    /*
     * restrict 关键字有两个读者：
     *
     *  - 一个是编译器，该关键字告知编译器可以自由假定一些优化方案。
     *  - 另一个读者是用户，该关键字告知用户要使用满足 restrict 要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，
     *    但是无视它后果自负。
     */
}